1.堆内存过小，对象过多，会导致内存溢出oom
2.堆内存越大，gc次数越少，单次gc时间越长。
3.g1单次gc时间非常短，但由于次数较多，整体吞吐不如并行gc
4.如果分配速率过高导致的minor gc 频繁或者导致了major gc频繁（提升了不应该提升的对象） 可以适当调整young区内存大小；

1）并不是堆内存越大越好，堆内存小的时候GC会比较频繁，但STW时间会比较短，会影响吞吐量。堆内存过大 则GC频率减少，
但是每次GC的STW时间会延长，导致系统响应延迟时间变长。
2）实际工作中，FullGC应该比较少，尤其是在项目启动时，如果出现就要调整young区大小和对应生成大对象代码。
3）充分考虑分配率和提升率，分配率高就要提高新生代大小，用于减小GC频率同时不影响吞吐量。但也不能设置太大， 
导致一次GC停顿时间太长，影响业务吞吐。
4）现实工作中要对系统的jvm调优，需要根据系统流量最大的几个api进行压测，同时打印GC日志，再分析GC日志，
 再根据日志情况调整参数，包括堆内存大小，是否启动自适应，收集器类型，新生代大小， 并行收集的线程数， 对象升代的阈值等)，
  再压测， 记录， 分析，直到最终确定最优的JVM参数。